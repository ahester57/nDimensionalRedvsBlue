<!DOCTYPE html>
<html>
<head>
<!-- Austin Hester HW4
	09/19/17
	A pretty strange grid game
	Red Marker starts at lower-left position, blue marker starts opposite. The game ends 
	when red reaches blue's home OR blue reaches red's home.
	Movement is random.
	Group:
    	
-->
</head>
<body>
<!-- Start game, keep clicking to play again and again -->
<button onclick="beginMoving()">Begin Strange Game</button><br/>
<p id="dims">Dimensions: </p>
<input id="dimpick" type="number" min="2" max="5">
<p id="gridsize">Grid size: </p>
<input id="gridpick" type="number" min="2" max="8">
<p id="steps">Warning!!! Playing this game may lead to seizures! Continue at your own risk!</p>
<p id="marker"></p>
<p id="red">Red starts at bottom-left and wins at top-right.</p>
<p id="blue">Blue starts at top-right and wins at bottom-left.</p>
<p id="max">Pick a color and hopefully you will win.</p>
<p id="average">Good luck, you'll need it.</p>
<canvas id="myCanvas" width="200" height="200" style="border:1px solid #c3c3c3;">
Your browser does not support the HTML5 canvas tag.
</canvas>

<script>
var red = '#ff1a1a';
var blue = '#1affff';
/************************ Tile Object **************************/
// For holding tile information
var Tile = function(loc) {
	this.indices = [];
	this.setLocation(loc);
	// following 3 for drawing
	this.width = 80;
	this.x = this.indices[0] * this.width + 30;
	this.y = this.indices[1] * this.width + 40;
	this.touches = 0;
	this.redMarked = false;
	this.blueMarked = false;
	this.color = "white";
};
// Marks tile and adds a touch
Tile.prototype.setMarked = function(flag, color) {
	if (color == red)
		this.redMarked = flag;
	if (color == blue)
		this.blueMarked = flag;
	if (flag) 
		this.touches++;
}
// Sets location of tile
Tile.prototype.setLocation = function(loc) {
	var ind = loc.getIndices();	// indices of new location
	for (var i = 0; i < ind.length; i++) {
		this.indices[i] = ind[i];
	}
}
// Gets location of tile
Tile.prototype.getLoc = function() {
	return new Location(this.indices);
}
// Sets color of tile
Tile.prototype.setColor = function(color) {
	if (this.color == "white") {
		this.color = color;	// text color
	} else if (this.color != color) {
		this.color = "magenta";	// when touched by both
	}
}
/************************ Location Object **********************/
// Location takes a size n 1d-array of values
// n will be the number of dimensions in the simulation
var Location = function(loclist) {
	this.indices = [];
	for (var i = 0; i < loclist.length; i++) {
		this.indices.push(loclist[i]);
	}
};
// return specific indices 
Location.prototype.getIndices = function() {
	return this.indices;
}
// tests if location is the same
Location.prototype.matches = function(other) {
	var oloc = other.getIndices();
	for (var i = 0; i < oloc.length; i++) {
		if (this.indices[i] != oloc[i])
			return false;
	}
	return true;
}
// tests if location is in grid
Location.prototype.isInGrid = function(gridsize) {
	for (var i = 0; i < this.indices.length; i++) {
		if (this.indices[i] < 0 || this.indices[i] >= gridsize) {
			return false;
		}
	}
	return true;
}
/************************ Marker Object ************************/
// Holding marker information
var Marker = function(loc, color) {
	this.homeloc = loc;
	this.indices = [];
	this.setLocation(loc);
	this.color = color;
	this.moves = 0;
	this.gotSentHome = 0;
};
// Sets location of marker
Marker.prototype.setLocation = function(loc) {
	this.moves++;
	var ind = loc.getIndices();	// indices of new location
	for (var i = 0; i < ind.length; i++) {
		this.indices[i] = ind[i];
	}
}
// Gets location of marker
Marker.prototype.getLoc = function() {
	return new Location(this.indices);
}
// Sends home
Marker.prototype.sendHome = function() {
	this.gotSentHome++;
	this.moves--;	// sending home doesn't count as a move
	this.setLocation(this.homeloc);
	setTileMarker(this);
}
/************************ Global Variables *********************/
var ROWS = 8;	// rows are equal for each axis
var DIMS = 4; 	// dimensions
var tiles;
var redmarker, bluemarker;
var gameLoop;
var count;
/************************ Build the tiles *********************/
// Make new list of tiles
function buildTiles(ndims, rows) {
	var tiles = [];
	var locs = [];

	var count = rows ** ndims;
	for (var d = 0; d < count; d++) {
		// initialize arrays for each possible location at zeros
		for (var f = 0; f < ndims; f++) {
			locs[d] = [];
		}
	}
	var pattern = count;
	for (var d = 0; d < ndims; d++) {
		// initialize arrays for each possible location at zeros
		pattern = pattern / rows;
		buildDimension(pattern, rows, locs);
	}
	for (var d = 0; d < count; d++) {
		tiles.push(new Tile(new Location(locs[d])));
	}
	console.log(tiles);
	// we need a 0, 1, ..., rows-1 in each x, y, z, ...
	return tiles;
}
// voodoo magic occurs
function buildDimension(pattern, rows, locs) {
	var value;
	for (var i = 0; i < locs.length; i++) {
		if (pattern == 1)
			value = i % rows;
		else
			value = Math.floor((i % (pattern * rows)) / pattern);  
		locs[i].push(value);
	}
}
// @TODO 
function generateHomeLocations(ndims) {
	//return array of two arrays
	var red = [];
	var blue = [];
	var top = ROWS - 1;
	// puts blue at opposite corner of red
	for (var i = 0; i < ndims; i++) {
		if (i % 2 == 0) {
			red.push(0);
			blue.push(top);
		} else {
			red.push(top);
			blue.push(0);
		}
	}
	return [new Location(red), new Location(blue)];
}
/************************ Movement Functions *******************/
// This function is called onClick of the begin button
// Keeps track of marker location and grid statistics
function beginMoving() {
	// initiate all the stuffs
	var tdim = document.getElementById("dimpick").value;
	if (tdim != "") {
		DIMS = parseInt(tdim);
	}
	var trow = document.getElementById("gridpick").value;
	if (trow != "") {
		ROWS = parseInt(trow);
	}
	document.getElementById("dims").innerHTML = "Dimensions: " + DIMS;
	document.getElementById("gridsize").innerHTML = "Grid Size: " + ROWS + "x" + ROWS;
	var homes = generateHomeLocations(DIMS);
	redloc = homes[0];
	blueloc = homes[1];
	redmarker = new Marker(redloc, red);
	bluemarker = new Marker(blueloc, blue);
	tiles = buildTiles(DIMS, ROWS);
	count = 0;
	setTileMarker(redmarker);
	setTileMarker(bluemarker);
	clearInterval(gameLoop);
	clearOutput();
	if (DIMS <= 3)
		drawGrid();
	gameLoop = setInterval(function(){step();}, 10);
}

// This calculates next movement, tries to move there, and redraws grid
function step() {
	count++;
	// take turns
	if (count % 2 == 1)
		var turnmarker = redmarker;
	else
		var turnmarker = bluemarker;
	
	moveMarker(turnmarker);
	if (DIMS <=3) 
		drawGrid();
	document.getElementById("steps").innerHTML = "Total iterations: " + count;
	// test if over
	testPoint(turnmarker);
}

// tries to move given marker
function moveMarker(marker) {
	var loc = getNextLocation(marker, DIMS);
	//console.log(loc.getIndices() + marker.color);
	// Make sure new move is inside the grid
	// account for a "no-move move"
	// if (!(loc.isInGrid(ROWS))) {
	// 	marker.moves++;
	// 	setTileMarker(marker);
	// 	return;
	// }
	marker.setLocation(loc);	// set new marker if inside the grid
	setTileMarker(marker); // every iteration gives 1 touch to current tile no matter if it tried to move off the grid or 0
}

// sets marked tile
function setTileMarker(marker)  {	// gonna have to redo this
	for (var i = 0; i < tiles.length; i++) {
		if (tiles[i].getLoc().matches(marker.getLoc())) {
			tiles[i].setMarked(true, marker.color);
			tiles[i].setColor(marker.color);
		} else {
			tiles[i].setMarked(false, marker.color);
		}
	}
}
/************************ Testing Function *********************/
// either does: nothing, sends one home, or ends game
// why two of the same??? combine.
function testPoint(marker) {
	if (marker.moves >= 1000000) {
		endGame();	// if either is at 100000, rarely if ever happens
		return;
	}
	//console.log(marker.getLoc().matches(new Location(marker.getLoc().getIndices())));
	var tile = getTileByLoc(marker.getLoc());
	if (marker.color == red) {
		//console.log("red");
		if (tile.blueMarked == true) {
			// sends home
			marker.sendHome();
			document.getElementById("marker").innerHTML = "RED sent home @ move: " + marker.moves;
		} else if (marker.getLoc().matches(bluemarker.homeloc)) {
			endGame();
			document.getElementById("marker").innerHTML = "RED wins";
		}
	} else if (marker.color == blue) {
		//console.log("blue");
		if (tile.redMarked == true) {
			// sends home
			marker.sendHome();
			document.getElementById("marker").innerHTML = "BLUE sent home @ move: " + marker.moves;
		} else if (marker.getLoc().matches(redmarker.homeloc)) {
			endGame();
			document.getElementById("marker").innerHTML = "BLUE wins";
		}
	}
}
/************************ getStuff Functions *******************/
// generate next location of given marker
function getNextLocation(marker, dims) {
	//console.log(marker.getLoc().getIndices());
	var ogLoc = marker.getLoc();
	var tempMarker = marker.getLoc().getIndices();
	var line = Math.floor(Math.random()*dims);	// whether traversing row or column
	var N = Math.floor(Math.random()*3);	// either 0, 1, 2
	// either left/right or up/down depending on Math
	if (Math.floor(Math.random()*2) == 0) {
		tempMarker[line] += N;
	} else {
		tempMarker[line] -= N;
	}

	//console.log(tempMarker);
	var newLoc = new Location(tempMarker);
	if (newLoc.isInGrid(ROWS)){
		return newLoc;
	} else {
		return ogLoc;
	}
}
// gets tile by coords
function getTileByLoc(loc) {	// change to take location
	var tempLoc;
	for (var i = 0; i < tiles.length; i++) {
		if (tiles[i].getLoc().matches(loc))
			return tiles[i];
	}

	console.log("is null");
	return null;
}

// averages touches
function getAvgTouches() {
	var total = 0;
	for (var i = 0; i < tiles.length; i++) {
		total += tiles[i].touches;
	}
	var average = total / (tiles.length);
	return average;
}
// gets location(s) of max touches and maximum value
function getMaxTouches() {
	var result = [];
	var max = 0;
	for (var i = 0; i < tiles.length; i++) {
		if (tiles[i].touches > max)
				max = tiles[i].touches;
	}
	result.push(max);	// push max count to result
	var array = [];
	for (var i = 0; i < tiles.length; i++) {
		if (tiles[i].touches == max)
			array.push([tiles[i].row, tiles[i].col]);	// redo
	}
	result.push(array);	// push list of locations to result
	return result;	
}
/************************ End It Function **********************/
//ends game
function endGame() {
	clearInterval(gameLoop);
	displayOutput();
}
/************************ Draw Function ************************/
// draw grid, marker, and touches
function drawGrid() {
	var canvas = document.getElementById("myCanvas");
	var context = canvas.getContext("2d");
	var p = tiles[0].width / 4;			// padding
	var bw = ROWS * (tiles[0].width) + p;	// width
	var bh = ROWS * (tiles[0].width) + p;	// height
	var tx, ty, twidth;

	context.canvas.width = bh + (p/2 * ROWS + p);	// set canvas size
	context.canvas.height = bw + (p/2 * ROWS + p);
	context.globalAlpha = 1.0
	context.fillStyle = "black";
	context.fillRect(0, 0, canvas.width, canvas.height);
	var color;
	// draw tiles
	for (var i = 0; i < tiles.length; i++) {
		tx = tiles[i].x;
		ty = tiles[i].y;
		twidth = tiles[i].width;
		context.moveTo(tx, ty);
		context.lineTo(tx, ty + twidth);
		context.moveTo(tx, ty);
		context.lineTo(tx + twidth, ty);
	}
	// complete borders
	tx = tiles[0].x;
	ty = tiles[0].y;
	twidth = tiles[0].width;
	context.moveTo(tx + (twidth * ROWS), ty);
	context.lineTo(tx + (twidth * ROWS), ty + (twidth * ROWS));
	context.lineTo(tx, ty + (twidth * ROWS));
	color = '#' + Math.floor(Math.random()*16777215).toString(16);
	context.strokeStyle = color;
	context.lineWidth = 2;
	context.stroke();

	// draw circle / touch count
	for (var i = 0; i < tiles.length; i++) {
		twidth = tiles[i].width;
		tx = tiles[i].x;
		ty = tiles[i].y;
		if (tiles[i].redMarked) {	// draw marker
			context.moveTo(tx, ty);
			context.beginPath();
			context.globalAlpha = 0.8
			context.arc(tx + twidth/2, ty + twidth/2, twidth/2 - p, 0, 2*Math.PI);
			context.fillStyle = red;
			context.fill();
		} else if (tiles[i].blueMarked) {	// draw marker
			context.moveTo(tx, tiles[i].y);
			context.beginPath();
			context.globalAlpha = 0.8
			context.arc(tx + twidth/2, ty + twidth/2, twidth/2 - p, 0, 2*Math.PI);
			context.fillStyle = blue;
			context.fill();
		} else {	// fill with touches
			context.moveTo(tx, ty);
			context.beginPath();
			context.globalAlpha = 0.7;
			context.font="bold 20px Tahoma";
			//color = '#' + Math.floor(Math.random()*16777215).toString(16);	// for craziness
			color = "white";
			//var color = tiles[i].color;
			context.fillStyle = tiles[i].touches > 0 ? tiles[i].color : color;
			var loc = tiles[i].getLoc().getIndices();
			var dims = loc.length;
			
			if (dims <= 2) {
				context.fillText(tiles[i].touches.toString(), tx + 10,
				 	ty + twidth - 10);
			} else {
				context.fillText(tiles[i].touches.toString(), tx + 5 + ((loc[dims-1]*2)*(dims**2 % twidth)),
				 	ty + twidth - 10 - ((loc[dims-1]*2)*(dims**2 % twidth)));
			}
		}
	}
}
/************************ "Good-enough" Front-end **************/
// output information
function displayOutput() {
	if (count < 1000000) {
		document.getElementById("steps").innerHTML = "Total iterations: " + count;
	} else {
		document.getElementById("steps").innerHTML = "Max iterations (1,000,000) reached. Game stopped.";
	}
	document.getElementById("red").innerHTML = "Red: " + redmarker.moves + " moves." + " Sent home " + redmarker.gotSentHome + " times.";
	document.getElementById("blue").innerHTML = "Blue: " + bluemarker.moves + " moves." + " Sent home " + bluemarker.gotSentHome + " times.";
	var maxx = getMaxTouches();
	document.getElementById("max").innerHTML = "Maximum touches: " + maxx[0] + " at: " + maxx[1].join(" | ");
	document.getElementById("average").innerHTML = "Average touches: " + getAvgTouches();
}
// clears information when starting new game
function clearOutput() {
	document.getElementById("steps").innerHTML = "";
	document.getElementById("marker").innerHTML = "";
	document.getElementById("red").innerHTML = "";
	document.getElementById("blue").innerHTML = "";
	document.getElementById("max").innerHTML = "";
	document.getElementById("average").innerHTML = "";
}
</script>
</body>
</html>