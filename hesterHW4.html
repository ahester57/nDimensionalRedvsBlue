<!DOCTYPE html>
<html>
<head>
<!-- Austin Hester HW4
	09/19/17
	A pretty strange grid game
	Red Marker starts at lower-left position, blue marker starts opposite. The game ends 
	when red reaches blue's home OR blue reaches red's home.
	Movement is random.
	Group:
    	
-->
</head>
<body>
<!-- Start game, keep clicking to play again and again -->
<button onclick="beginMoving()">Begin Strange Game</button><br/>
<p id="steps">Warning!!! Playing this game may lead to seizures! Continue at your own risk!</p>
<p id="marker"></p>
<p id="red">Red starts at bottom-left and wins at top-right.</p>
<p id="blue">Blue starts at top-right and wins at bottom-left.</p>
<p id="max">Pick a color and hopefully you will win.</p>
<p id="average">Good luck, you'll need it.</p>
<canvas id="myCanvas" width="200" height="200" style="border:1px solid #c3c3c3;">
Your browser does not support the HTML5 canvas tag.
</canvas>

<script>
var red = '#ff1a1a';
var blue = '#1affff';
/************************ Tile Object **************************/
// For holding tile information
var Tile = function(i, j) {
	this.row = i;
	this.col = j;
	this.width = 60;
	this.x = i * this.width + 30;
	this.y = j * this.width + 40;
	this.touches = 0;
	this.redMarked = false;
	this.blueMarked = false;
	this.color = "white";
};
// Marks tile and adds a touch
Tile.prototype.setMarked = function(flag, color) {
	if (color == red)
		this.redMarked = flag;
	if (color == blue)
		this.blueMarked = flag;
	if (flag) 
		this.touches++;
}
// Sets color of tile
Tile.prototype.setColor = function(color) {
	if (this.color == "white") {
		this.color = color;	// text color
	} else if (this.color != color) {
		this.color = "magenta";	// when touched by both
	}
}
/************************ Location Object **********************/
// Location takes a size n 1d-array of values
// n will be the number of dimensions in the simulation
var Location = function(loclist) {
	this.indices = [];
	for (var i = 0; i < loclist.length; i++) {
		this.indices.push(loclist[i]);
	}
};
Location.prototype.getIndices = function() {
	return this.indices;
}
Location.prototype.matches = function(other) {
	var oloc = other.getIndices();
	for (var i = 0; i < oloc.length; i++) {
		if (this.indices[i] != oloc[i])
			return false;
	}
	return true;
}
/************************ Marker Object ************************/
// Holding marker information
var Marker = function(loc, color) {
	this.homeloc = loc;
	this.indices = [];
	this.setLocation(loc);
	this.color = color;
	this.moves = 0;
	this.gotSentHome = 0;
};
// Sets location of marker
Marker.prototype.setLocation = function(loc) {
	this.moves++;
	var ind = loc.getIndices();	// indices of new location
	for (var i = 0; i < ind.length; i++) {
		this.indices[i] = ind[i];
	}
	this.row = ind[0];
	this.col = ind[1];
}
// Gets location of marker
Marker.prototype.getLoc = function() {
	return new Location(this.indices);
}
// Sends home
Marker.prototype.sendHome = function() {
	this.gotSentHome++;
	this.moves--;	// sending home doesn't count as a move
	this.setLocation(this.homeloc);
	setTileMarker(this);
}
/************************ Global Variables *********************/
var ROWS = 10;	// rows are equal for each axis
var tiles;
var redmarker, bluemarker;
var gameLoop;
var count;
/************************ Build the tiles *********************/
// Make new list of tiles
function buildTiles(ndims, rows) {
	var tiles = [];
	for (var i = 0; i < rows; i++) {
		for (var j = 0; j < rows; j++) {
			tiles.push(new Tile(i, j));
		}
	}
	return tiles;
}
/************************ Movement Functions *******************/
// This function is called onClick of the begin button
// Keeps track of marker location and grid statistics
function beginMoving() {
	// initiate all the stuffs
	redloc = new Location([0, ROWS-1]);
	blueloc = new Location([ROWS-1, 0]);
	redmarker = new Marker(redloc, red);
	bluemarker = new Marker(blueloc, blue);
	tiles = buildTiles(2,ROWS);
	count = 0;
	setTileMarker(redmarker);
	setTileMarker(bluemarker);
	clearInterval(gameLoop);
	clearOutput();
	drawGrid();
	gameLoop = setInterval(function(){step();}, 0);
}

// This calculates next movement, tries to move there, and redraws grid
function step() {
	count++;
	// take turns
	if (count % 2 == 1)
		var turnmarker = redmarker;
	else
		var turnmarker = bluemarker;
	
	moveMarker(turnmarker);
	drawGrid();
	document.getElementById("steps").innerHTML = "Total iterations: " + count;
	// test if over
	testPoint(turnmarker);
}

// tries to move given marker
function moveMarker(marker) {
	var loc = getNextLocation(marker);
	var indices = loc.getIndices();
	// Make sure new move is inside the grid
	for (var i = 0; i < indices.length; i++) {
		if (indices[i] < 0 || indices[i] >= ROWS) {
			// account for a "no-move move"
			marker.moves++;
			setTileMarker(marker);
			return;
		}
	}
	marker.setLocation(loc);	// set new marker if inside the grid
	setTileMarker(marker); // every iteration gives 1 touch to current tile no matter if it tried to move off the grid or 0
}

// sets marked tile
function setTileMarker(marker)  {	// gonna have to redo this
	for (var i = 0; i < tiles.length; i++) {
		if (tiles[i].row == marker.row && tiles[i].col == marker.col) {
			tiles[i].setMarked(true, marker.color);
			tiles[i].setColor(marker.color);
		} else {
			tiles[i].setMarked(false, marker.color);
		}
	}
}
/************************ Testing Function *********************/
// either does: nothing, sends one home, or ends game
function testPoint(marker) {
	if (marker.moves >= 1000000) {
		endGame();	// if either is at 100000, rarely if ever happens
		return;
	}
	if (marker.color == red) {
		if (getTileByLoc(marker.row, marker.col).blueMarked == true) {
			// sends home
			marker.sendHome();
			document.getElementById("marker").innerHTML = "RED sent home @ move: " + marker.moves;
		} else if (marker.col == 0 && marker.row == ROWS-1) {
			endGame();
			document.getElementById("marker").innerHTML = "RED wins";
		}
	} else if (marker.color == blue) {
		if (getTileByLoc(marker.row, marker.col).redMarked == true) {
			// sends home
			marker.sendHome();
			document.getElementById("marker").innerHTML = "BLUE sent home @ move: " + marker.moves;
		} else if (marker.col == ROWS-1 && marker.row == 0) {
			endGame();
			document.getElementById("marker").innerHTML = "BLUE wins";
		}
	}
}
/************************ getStuff Functions *******************/
// generate next location of given marker
function getNextLocation(marker) {
	var loc = [];
	var tempMarker = [marker.row, marker.col];
	var line = Math.floor(Math.random()*2);	// whether traversing row or column
	var N = Math.floor(Math.random()*3);	// either 0, 1, 2
	// either left/right or up/down depending on Math
	if (Math.floor(Math.random()*2) == 0) {
		tempMarker[line] += N;
	} else {
		tempMarker[line] -= N;
	}
	loc.push(tempMarker[0]);
	loc.push(tempMarker[1]);
	return new Location(loc);
}
// gets tile by coords
function getTileByLoc(loc) {	// change to take location
	for (var i = 0; i < tiles.length; i++) {
		if (tiles[i].row == row && tiles[i].col == col)
			return tiles[i];
	}
	return null;
}

// averages touches
function getAvgTouches() {
	var total = 0;
	for (var i = 0; i < tiles.length; i++) {
		total += tiles[i].touches;
	}
	var average = total / (tiles.length);
	return average;
}
// gets location(s) of max touches and maximum value
function getMaxTouches() {
	var result = [];
	var max = 0;
	for (var i = 0; i < tiles.length; i++) {
		if (tiles[i].touches > max)
				max = tiles[i].touches;
	}
	result.push(max);	// push max count to result
	var array = [];
	for (var i = 0; i < tiles.length; i++) {
		if (tiles[i].touches == max)
			array.push([tiles[i].row, tiles[i].col]);
	}
	result.push(array);	// push list of locations to result
	return result;	
}
/************************ End It Function **********************/
//ends game
function endGame() {
	clearInterval(gameLoop);
	displayOutput();
}
/************************ Draw Function ************************/
// draw grid, marker, and touches
function drawGrid() {
	var canvas = document.getElementById("myCanvas");
	var context = canvas.getContext("2d");
	var p = tiles[0].width / 4;			// padding
	var bw = ROWS * (tiles[0].width) + p;	// width
	var bh = ROWS * (tiles[0].width) + p;	// height

	context.canvas.width = bh + (p/2 * ROWS + p);	// set canvas size
	context.canvas.height = bw + (p/2 * ROWS + p);
	context.fillStyle = "black";
	context.fillRect(0, 0, canvas.width, canvas.height);
	var color;
	// draw tiles
	for (var i = 0; i < tiles.length; i++) {
		context.moveTo(tiles[i].x, tiles[i].y);
		context.lineTo(tiles[i].x, tiles[i].y + tiles[i].width);
		context.moveTo(tiles[i].x, tiles[i].y);
		context.lineTo(tiles[i].x + tiles[i].width, tiles[i].y);
	}
	// complete borders
	context.moveTo(tiles[0].x + (tiles[0].width * ROWS), tiles[0].y);
	context.lineTo(tiles[0].x + (tiles[0].width * ROWS), tiles[0].y + (tiles[0].width * ROWS));
	context.lineTo(tiles[0].x, tiles[0].y + (tiles[0].width * ROWS));
	color = '#' + Math.floor(Math.random()*16777215).toString(16);
	context.strokeStyle = color;
	context.lineWidth = 2;
	context.stroke();

	// draw circle / touch count
	for (var i = 0; i < tiles.length; i++) {
		if (tiles[i].redMarked) {	// draw marker
			context.moveTo(tiles[i].x, tiles[i].y);
			context.beginPath();
			context.arc(tiles[i].x + tiles[i].width/2, tiles[i].y + tiles[i].width/2, tiles[i].width/2 - p, 0, 2*Math.PI);
			context.fillStyle = red;
			context.fill();
		} else if (tiles[i].blueMarked) {	// draw marker
			context.moveTo(tiles[i].x, tiles[i].y);
			context.beginPath();
			context.arc(tiles[i].x + tiles[i].width/2, tiles[i].y + tiles[i].width/2, tiles[i].width/2 - p, 0, 2*Math.PI);
			context.fillStyle = blue;
			context.fill();
		} else {	// fill with touches
			context.moveTo(tiles[i].x, tiles[i].y);
			context.beginPath();
			context.font="bold 22px Georgia";
			//color = '#' + Math.floor(Math.random()*16777215).toString(16);	// for craziness
			color = "white";
			//var color = tiles[i].color;
			context.fillStyle = tiles[i].touches > 0 ? tiles[i].color : color;
			context.fillText(tiles[i].touches.toString(), tiles[i].x + 10,
				 tiles[i].y + tiles[i].width - 10);
		}
	}
}
/************************ "Good-enough" Front-end **************/
// output information
function displayOutput() {
	if (count < 1000000) {
		document.getElementById("steps").innerHTML = "Total iterations: " + count;
	} else {
		document.getElementById("steps").innerHTML = "Max iterations (1,000,000) reached. Game stopped.";
	}
	document.getElementById("red").innerHTML = "Red: " + redmarker.moves + " moves." + " Sent home " + redmarker.gotSentHome + " times.";
	document.getElementById("blue").innerHTML = "Blue: " + bluemarker.moves + " moves." + " Sent home " + bluemarker.gotSentHome + " times.";
	var maxx = getMaxTouches();
	document.getElementById("max").innerHTML = "Maximum touches: " + maxx[0] + " at: " + maxx[1].join(" | ");
	document.getElementById("average").innerHTML = "Average touches: " + getAvgTouches();
}
// clears information when starting new game
function clearOutput() {
	document.getElementById("steps").innerHTML = "";
	document.getElementById("marker").innerHTML = "";
	document.getElementById("red").innerHTML = "";
	document.getElementById("blue").innerHTML = "";
	document.getElementById("max").innerHTML = "";
	document.getElementById("average").innerHTML = "";
}
</script>
</body>
</html>